自我介绍，实习做了什么

# 1. 封装一个hooks，支持setState防抖

```js
function useDebounce (value, delay) {
    const [debouncedValue, setDebouncedValue] = useState(value);
    useEffect(() => {
        const fn = debounce(() => {
            setDebouncedValue(value);
        },delay);
        return () => {
            clearTimeout(fn);
        }
    }, [value]);
    return debouncedValue;
}

```

# 2. hooks 闭包陷阱

```js
const FunctionComponent = () => {
  const [value, setValue] = useState(1)
  const ref = useRef(value);
  const log = () => {
    setTimeout(() => {
      alert(ref.current)
    }, 1000);
  }
  useEffect(() => {
      ref.current = value;
  },[value])
  return (
    <div>
      <p>FunctionComponent</p>
      <div>value: {value}</div>
      <button onClick={() => setValue(value + 1)}>add</button>
      <br/>
      <button onClick={log}>alert</button>
    </div>
  )
}
------------------------------------------------------------------------------
const Counter = () => {
  const [value, setValue] = useState(0)

  useEffect(() => {
    const timer = setInterval(() => {
      console.log('new value:', value+1)
 	// 解决方法
      setValue(v => v + 1)
    }, 1000);
    return () => {
      clearInterval(timer)
    }
  }, [])

  return (
    <div>
      <p>Counter</p>
      <div>count: {value}</div>
    </div>
  )
}


```

# 3. 实现 洋葱模型的 compose

```js
const compose = (...args) => {
    
    const fn = async function (val) {
        let res = val;
        for(let i = args.length - 1; i >= 0; i--) {
            res = await args[i](res);
            console.log(res);
        } 
        return res;
    }
    return fn;
}

const add = x => new Promise((resolve) => {
    setTimeout(() => {
        resolve(x + 10)
    }, 1000)
}); 
const multiply = x => x * 10;
(async () => {
    let res = await compose(multiply, add)(10);
    console.log(res)
})()
```

# 4. react 16,17,18 改动

# 5. 在实习中有学到什么

# 6. ts 中 的 never、unknown、any

# 7. ts中的泛型类型推断

# 8. redux中的数据流

# 9. craco

# 10.  facade pattern 有听过吗？



总结：被第一题吓到了，后面的其实也不难。。。。。