# TCP连接建立过程

## **三次握手**

 - 一开始，客户端处于closed状态，服务端监听某个端口处于listen状态。客户端请求建立连接，发送 `SYN=1` & `客户端随机初始化的一个序列号`，进入SYN_SENT状态

 - 服务端收到信息，返回`ACK=1` & `SYN=1` & `客户端发来的序列号+1` & `服务端初始化的序列号`，进入SYN_RCVD阶段

 - 客户端收到信息，返回 `ACK=1` & `服务端发来的序号+1`，进入ESTABLISHED状态。服务端收到客户端发来的报文后，也进入ESTABLISHED状态


## **为什么是三次握手、不是四次、不是两次？**

 - **避免历史连接**
   
   三次握手的首要原因是为了避免旧的重复连接初始化而造成的混乱。

        有这样一种情况，客户端首先发出了SYN=1，seq=100的请求建立连接的报文，后来这个报文在网络中被堵塞。之后，客户端宕机，重启后，又重新发了一个SYN=1,seq=110的报文，请求建立连接，此时客户端期待收到ACK=1、SYN=1、seq=111的报文，但是呢，可能之前seq=100的报文先到达了服务端，服务端返回了seq=101的报文，如果是两次握手，这是服务端直接进入ESTABLISHED状态，客户端不会进入，因为他没有收到他需要的报文。
   
 - **三次握手才可以同步双方的初始序列号**
   
       序列号是TCP实现可靠传输的基础

       两次握手，只能保证一方的序列号被成功接受，而三次握手中的第二步实际上是把 应答客户端的序列号 + 发送服务端的初始序列号融合成一步了，所以也没必要四次。

 - **三次握手可以避免资源浪费**
   
       这个实际上和第一点很像，如果两次连接就能连接上，会产生很多冗余连接，造成资源浪费。



# TCP连接断开过程

## TCP四次挥手以及状态变迁

 - 客户端和服务端起初都处在ESTABLISHED状态，客户端发起断开连接请求，发送FIN=1，进入FIN_WAIT1阶段
  
 - 服务端收到客户端的报文后，表示还有一些数据没有发送完，需要再等一下，发送ACK=1，自己进入CLOSED_WAIT阶段。客户端收到这个报文后，进入FIN_WAIT2阶段

 - 服务端发送完全部数据，并表示此时可以关闭连接了，发送FIN=1字段，自己进入LAST_ACK阶段
  
 - 客户端接收到服务端第二次挥手后，发送ACK=1，代表可以关闭请求了，自己进入TIME_WAIT阶段，等待两个MSL后，进入CLOSED阶段，服务端收到客户端的第四次挥手后，进入CLOSED阶段


## 为什么客户端第四次挥手后 还要等待 2 MSL 再关闭连接？

  `MSL`是报文最大生存时间的简称，这个是为了确保服务端能够正确收到客户端发出的最后一个ACK报文，如果没有收到的话，在这个阶段，服务端会重发FIN=1（第三次挥手），当客户端收到新的FIN后，TIME_WAIT会重新计时

  相当于允许报文丢失一次，客户端发送ACK，服务端重发FIN，一来一回 刚好2MSL


## 为什么要挥手四次？

其实本质上，握手也是3次，只不过是第二次握手把ACK和SYN=1合并在一起了，但是挥手不行，服务端需要等待数据完成发送，才能发送FIN，所以会多一次

## 第一次挥手丢失会发生什么？

客户端会重发FIN报文，当达到最大重发次数时，直接进入closed状态

## 第二次挥手丢失会发生什么？

ACK报文是不会重传的，所以，这里客户端会重传FIN报文，直到收到服务端的FIN报文，或达到最大重发次数。

## 第三次挥手丢失，会发生什么？

服务端会重发FIN报文，直到达到最大重发次数

## 第四次挥手丢失，会发生什么？

服务端会重发FIN报文，直到达到最大重发次数，或客户端的TIME_WAIT时间到，返回RST，连接异常终止。

