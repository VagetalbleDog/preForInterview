# 自我介绍

# position的几个值

# 相对定位中 z-index 的排布问题

没懂他什么意思，相对定位不是没有脱流吗？怎么重叠在一起呢？

# css手写题

简单来说就是一个header固定定位，当header 与 一个 nav 相遇后，header 和 nav 一起 fixed。

需要注意的是 sticky 在初始时 不会脱流，它相对的是啥？

> 一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的`overflow` 是 `hidden`, `scroll`, `auto`, 或 `overlay`时），即便这个祖先不是最近的真实可滚动祖先。

# 手写防抖函数

# 实现一个函数

要求使用reduce， 主要是异步的问题。。。。

```js
/*
实现一个 composition 函数，要求：
1，该方法接收 不定数量 的一组函数（a, b, c, …）作为参数，并返回一函数 A；
2，该方法接收的所有函数都会接收一个具体参数并返回一个值；
3，可以通过 A(arg) 的方式调用 A 函数，其作用是顺次执行 composition 所接收的所有函数，每个函数的输入值是前一个函数的返回值，且 arg 为首位函数的参数。
*/

function a(arg) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(arg + 1);
        }, 1000);
    });
}
function b(arg) {
    return arg + 2;
}
function c(arg) {
    return arg + 3;
}
function composition(...fns) {
    // here is your code
    return async function (arg) {
        const res = await fns.reduce(async (pre, fn) => {
            const preVal = await pre;
            return await fn.call(this, preVal);
        }, arg);
        return res;
    };
}
const compositionFunc = composition(a, b, c);
// should be 7
compositionFunc(1).then((res) => {
    console.log(res);
});
```

# 自己想一个组件写出来。。。

List组件

```js
function List(props) {
    const {data, offset, total} = props;
    const [index,setIndex] = useState(0);
    function handlePrev() {
        if(index > 0) {
            setIndex(index - 1);
        }
    }
    function handleNext() {
        const maxPage = Math.ceil(total / offset);
        if(index < maxPage) {
            setIndex(index + 1);
        }
    }
    return (<div>
        {
            data.slice(index,index + offset).map((v) => {
                return <div key={v.id}>{v}</div>
            }) 
        }
        <div className="prev" onClick={() => {handlePrev()}}>上一页</div>
        <div className="next" onClick={() => {handleNext()}}>下一页</div>
    </div>)
}
```



