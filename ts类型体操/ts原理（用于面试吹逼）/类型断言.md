# 什么是类型断言
类型断言（Type Assertion）可以用来手动指定一个值的类型。
```
值 as 类型
```
# 类型断言的用途

  - **将一个联合类型断言成其中一个类型**
```
interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function isFish(animal: Cat | Fish) {
    if (typeof (animal as Fish).swim === 'function') {
        return true;
    }
    return false;
}
```
  - **将一个父类型断言成更具体的子类型**
```
interface Person {
  name: string;
  age:number
}
interface ZWF extends Person {
  hello():void
}


function isZwf(person:Person){
  if(typeof (person as ZWF).hello === 'function'){
    return true
  }
  return false
}
```

  - **将any断言成任何更具体的类型(提高代码可维护性)**
  
举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any：
```
function getCacheData(key: string): any {
    return (window as any).cache[key];
}
```
那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：
```
function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData('tom') as Cat;
tom.run();
```
上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。


  - **将任何类型断言成any（防止编译器报错）**

理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。

当我们引用一个在此类型上不存在的属性或方法时，就会报错：
```
const foo: number = 1;
foo.length = 1;
```

上面的例子中，数字类型的变量 foo 上是没有 length 属性的，故 TypeScript 给出了相应的错误提示。

这种错误提示显然是非常有用的。

但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：
```
window.foo = 1;
```
上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。

此时我们可以使用 as any 临时将 window 断言为 any 类型：
```
(window as any).foo = 1;
```
在 any 类型的变量上，访问任何属性都是允许的。