> 常见手写题

# 常见JS手写

## 1. 手写实现new

```js
function myNew(con) {
    let obj = Object.create(con.prototype);
    let res = con.call(obj,[...arguments].slice(1));
    if((typeof res === "obj" ||  typeof res === "function") && res !== null) {
        return res;
    }
    return obj;
}
```

## 2. 手写实现call

```js
Function.prototype._call = function (context) {
    // 考虑null undefined 或者context不是对象的情况
    context = context ? Object(context) : window;
    context.fn = this; // 指向函数，所以肯定不能使用箭头函数
    let args = [];
    // 这里为什么推入的不是数字，而是数组的表达呢，这是为了防止，参数是字符串的形式
    for (let i = 1; i < arguments.length; i++) {
        args.push(`arguments[${i}]`);
    }
    let res = eval("context.fn(" + args + ")");
    delete context.fn;
    return res;
};
```

## 3. 手写实现apply

```js
Function.prototype._call = function (context, array) {
    // 考虑null undefined 或者context不是对象的情况
    context = context ? Object(context) : window;
    context.fn = this; // 指向函数，所以肯定不能使用箭头函数
    let arr = [];
    if (!array) {
        // 这里不能用长度判断，因为，不知道是否传入有参数，那么可能没有length这个属性
        res = context.fn();
    } else {
        for (let i = 0; i < array.length; i++) {
            arr.push("array[" + i + "]");
        }
        res = eval("context.fn(" + arr + ")");
    }
    delete context.fn;
    return res;
};

```

## 4. 手写bind

1. 返回一个新的函数（this的值改变），且这个函数的this值不会再被改变（闭包的原理)
2.  函数柯里化，也就是说可以先传递一部分参数 
3. 绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用 来构建一个值的，**原来提供的 this 就会被忽略**。并且会继承prototype上的值。

```js
Function.prototype._bind = function (context) {
    // 保存函数
    let fn = this;
    let args1 = [...arguments].splice(1); // 当然也可已使用
    Array.prototype.slice.call(arguments, 1);
    return function () {
        /* 不能在这里保存函数，这里的this会变成window */
        let args2 = [...arguments];
        fn.apply(context, [...args1, ...args2]);
    };
};
```

**实现new的效果：**

一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。且返回的实例还是会继承构造函数的构造器属性与原型属 性，并且能正常接收参数。

```js
Function.prototype.bind_ = function (contenxt) {
    let fn = this; // 保存函数
    let args1 = [...arguments].splice(1); // 当然也可已使用
    Array.prototype.slice.call(arguments, 1);
    let bound = function () {
        /* 不能在这里保存函数，这里的this会变成window */
        let args2 = [...arguments];
        fn.apply(this instanceof fn ? this : contenxt, [...args1, ...args2]); //或者 args1.concat(args2);
    };
    bound.prototype = fn.prototype;
    return bound;
};

```

**最终代码：**

```js
Function.prototype.bind_ = function (contenxt) {
    if (typeof this !== "function") {
        throw new Error(
            "Function.prototype.bind - what is trying to be bound is not callable"
        );
    }
    let fn = this;
    let args1 = [...arguments].splice(1);
    // 防止fn的原型被改变
    let fNOP = function () {};
    let bound = function () {
        let args2 = [...arguments];
        return fn.apply(this instanceof fn ? this : contenxt, [
            ...args1,
            ...args2,
        ]);
    };
    // 这里需要注意下
    fNOP.prototype = fn.prototype;
    bound.prototype = new fNOP();
    return bound;
};

```

## 5. 手写实现instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```js
function myInstanceof(left, right) {
    // 这里先用typeof来判断基础数据类型，如果是，直接返回false,可能还需要处理函数
    if (typeof left !== "object" || left === null) return false;
    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
    if (typeof right !== "function") {
        throw new Error("不是函数");
    }
    let proto = Object.getPrototypeOf(left);
    while (true) {
        if (proto === null) return false;
        if (proto === right.prototype) return true; //找到相同原型对象，返回true
        proto = Object.getPrototypeof(proto);
    }
}

```

## 6. 实现deepClone

从这里就可以引出weakMap的区别，和JavaScript的垃圾回收机制。 还要考虑到Symbol的赋值，如何获取对象的Symbol属性

```js
let cloneRegExp = function (reg = /d+/i) {
    let flags = reg.flags;
    console.log(flags);
    let newReg = new RegExp(reg.source, flags);
    newReg.lastIndex = reg.lastIndex;
    return newReg;
};
function deepClone(obj, hash = new WeakMap()) {
    if (obj === null || typeof obj !== "object") return obj;
    if (typeof obj === "function") return obj;
    if (obj instanceof RegExp) {
        return cloneRegExp(obj);
    }
    if (obj instanceof Date) {
        return cloneDate(obj);
    }
    // 处理循环引用
    if (hash.has(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor();
    hash.set(obj, cloneObj);
    for (let k in obj) {
        if (obj.hasOwnProperty(k)) {
            cloneObj[k] = deepClone(obj[k], hash);
        }
    }
    return cloneObj;
}
```

![image-20220802183237906](C:\Users\fujiaxu\AppData\Roaming\Typora\typora-user-images\image-20220802183237906.png)

## 7. 数组扁平化

[(9条消息) JavaScript之数组扁平化_我是真的垃圾啊的博客-CSDN博客](https://blog.csdn.net/fujiaxu666/article/details/122419876?spm=1001.2014.3001.5501)

## 8. 函数柯里化

原理：闭包，延长的变量的生命周期，保存了当前的环境，是的外部可以访问到内部的变量。 可以复用参数，比如打折。 使用fn.length可以获取函数需要的参数

```js
function currying(fn, ...args1) {
    if (typeof fn !== 'function') {
    	throw new TypeError()
  	}
    let len = fn.length;
    return function (...args2) {
        let arg = [...args1, ...args2];
        if (arg.length >= len) {
            return fn.apply(this, arg);
        } else {
            return currying.call(this, fn, ...arg);
        }
    };
}

```

## 9. 手写JSON

## 10. 手写lodash的get方法

## 11. 手写洗牌算法

```js
function shuffle(arr = []) {
    for (let i = arr.length - 1; i >= 0; i--) {
        let rIndex = Math.floor(Math.random() * i);
        let t = arr[i];
        arr[i] = arr[rIndex];
        arr[rIndex] = t;
    }
}
let arr = [1, 2, 3, 4, 5, 6, 7];
shuffle(arr);
console.log(arr);

```

## 12. 继承手写

## 13. 手写防抖节流

## 14. 手写Object.create()



# 设计模式

## 1. 发布订阅模式

# Promise手写题目

