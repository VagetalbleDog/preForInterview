## **简要介绍下项目**

业务方面：

登录功能：采用 Json web Token的形式去实现登录 防范CSRF攻击

路由：用Vue-router路由守卫实现权限管理

异步处理

面试的时候尽量把面试官往登录功能里带

## 登录功能（主要是前端网络安全）

### 登录和功能的具体实现

在后端将权限认证从session改变为JWT（通过drf-simpleJWT库实现）

Session验证的方式，发送登录请求验证账号密码登录后，服务端会产生一个会话，实际上就是在数据库中多了一个session，服务端返回一个session_id存储在浏览器的cookie中，每次发起请求时，自动携带此cookie，服务端拿到session id后，拿去跟数据库中的session中对应的session_id的权限进行比对，判断其权限。

而我项目中使用JWT 跟这个过程比较类似 

发送登录请求 验证账号密码后 服务端不会产生一个 session会话 而是 签署返回两个token，一个用于刷新获取新的token 一个用于鉴权 我的策略是将这两个token存储在local storage中，然后在请求时，我们要手动加上这个token用于鉴权，这样就可以防范CSRF了。

jwt为了防止被盗取，会自动刷新，当用于鉴权的token过期后，我们使用refresh token发起请求，获取新的鉴权token。

鉴权的具体过程由JWT的内部机制完成。这就是一个优秀轮子的好处。

### 为什么要用JWT？而不是session？

在我的理解中，session和Jwt的鉴权方式很像 只不过是 jwt提供了一种在浏览器端保持session状态的方式。

1、如果使用session的话，一般来说，我需要把这个会话存进数据库中，这样一来意味着我的每次请求 服务端都要与数据库做额外的交互 （由于需要鉴权的原因）。

2、session-id存储在cookie中，可能会造成csrf攻击

3、易实现，几乎每种语言都有支持JWT的第三方库

4、但是把鉴权方式改成Token后 ，对于令牌的存放和运输 又会产生一系列的安全问题，这也是需要考虑和解决的问题。

对于存放 一般有三种策略 cookie localStorage sessionStorage

对于运输token（浏览器端和服务器端进行交互），一般来说，我们要通过加密管道进行运输，通常是Https。

### Token会被伪造吗？

一般来说不会 因为每一个token 由服务器端进行签署 返回给客户端 正是因为如此 服务器端在收到一个token时 会验证它的origin是否安全。

### Token的存放策略

1. **WebStorage（包括localStorage和SessionStorage）**

   **优势：**

   - 相比于cookie而言 浏览器不会在发起Http请求时 自动携带任何WebStorage中的内容，使csrf攻击无法实现。
   - 只能由运行在和存入该数据的同一个域的Js代码才能访问，并且很容易的添加到Http请求头的Bearer字段中。

   **缺点：**

   - 由于Webstorage可以被js访问，那么他将有可能会被Xss攻击所窃取

2. **Http-only-cookie**

   **优势：**

   - Xss攻击无法盗取token
   - 浏览器在发起请求时自动携带
   - cookie可以在顶级域中创建，并在子域执行的请求中使用

   **劣势：**

   - 可能会被CSRF攻击
   - 服务器端需要去解析cookie，而不是像使用WebStorage一样，直接解析http请求头中的Authorization

3. **Javascript Accessible cookie**

   即document.cookie

   **优势：**

   - 防止CSRF攻击，通过设置path来确保哪些路径下的文件有权访问该cookie
   - 相比与webstorage来说，可以在顶级域创建 在子域中使用
   - 相比于Http-only-cookie来说，可以更直接的去存放token
   - 可以设置一个secure属性，来确保这个cookie只能被Https加密运输

   **劣势：**

   - 可能导致Xss攻击

   - 如果不设置path的话，也会随着浏览器自动提交。

   - 实现复杂

     

**总结**：对于大多数的应用场景，使用WebStorage无非是最佳的选择

原因：（我选择webStorage的原因）因为你只要创建了一个Web app，应对xss攻击是你必须需要考虑的事情。但是csrf就不一样了，如果不使用基于cookie的权限认证，甚至不需要去考虑CSRF。

选项三的话实现复杂，而且也有可能会造成csrf和xss同时不能防范的情况，我的项目也没有顶级域和多个子域这种情况的出现，所以不用考虑在多个子域中去实现复用。

### cookie有过期时间吗

可以在响应头中的set-cookie字段中的expires属性中设置

### cookie能跨域携带吗？

响应头的set-cookie字段里有个属性：domain可以设置该cookie可以在哪些域中被访问，顶级域中的cookie，子域也可以访问

### 怎么防止cookie被盗取？

一般来说给cookie设置HttpOnly

### token可以在服务间共享吗

token可以是无状态的，可以在多个服务间共享。由于token是无状态的，它一般完全由应用去管理，所以可以避开同源策略。

### token怎么生成的知道吗

Token 值是将请求源串以及 Secret 通过 MD5 算法生成的，用来提高传输过程参数的防篡改性。

### jwt是由哪几个部分组成？

- **header（头部）**

  主要包含：

  声明类型、声明加密的算法

- **payload（载荷）**

  标准中注册的声明

  公共的声明

  私有的声明（私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。比方说，可以存放账户名，但是不能存放密码）

- **signature（签证）**

  header（base64加密后的）

  payload（base64加密后的）

  secret（这个部分需要base64加密后的header和payload使用`·`连接成字符串，然后通过header中声明的加密方式进行加密）

  secret保存在服务端，用于签发和验证jwt。

### jwt到底是啥 和一般的token有啥区别？

- 可以这么理解，对于一般的token来说，服务端验证客户端发来的token还需要到数据库中进行一个数据的查询操作，（其实有点像session—id的感觉）。

- 使用jwt的话，服务端验证客户端发来的jwt就直接使用密钥校验就可以，不用数据库的查询，而且json格式的数据，在http数据传输时更加方便和轻量。

### 还有别的鉴权方式吗



### Localstorage和sessionStorage

1、localstorage和sessionstorage都是用于数据（一般来说是字符串）缓存的Web APIs，相对于cookie空间大，通过键值对方式进行缓存，并且他们都是window对象的属性之一

2、sessionStorage一般来说将数据存在网页窗口的进程内存或线程内存中，当浏览器关闭的时候sessionStorage的数据缓存也就自动清除了，localstorage将数据存在硬盘中，必须得手动清除才行。方法基本差不多 setItem、getItem、removeItem

3、localStorage存储空间大，可以封装localStorage设置时效时间 。大概思路就是封装一个MyLocalStorage，接受三个参数 key，value，time。

我们在封装localStorage时，还可以拓宽value值的限制类型，因为本身只能存储string类型，我们在封装时可以加一个类型检查的过程，如果是对象或者数组就调用相应方法，在每次存取操作的时候 都检查一下是否过期，如果过期就调用removeItem。

4、value只能是字符串 保存对象和数组等信息 可以先用JSON.stringify(obj) 然后存进去 然后用的时候 可以用JSON.parse()再转化为对象或数组使用

### CSRF 简单讲讲攻防

token验证、同源策略、axios、双重cookie、Http请求头中设置referer字段（判断请求来源是否合法）

### XSS简单讲讲攻防

**（1）输入过滤**

避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)

**（2）输出转义编码(响应头字段xss-protection)**

- 往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 [HTML 字符实体](http://www.w3school.com.cn/html/html_entities.asp)
- 将用户数据输出到html 标签的属性时，必须经过标签属性的转义。注意：不包含href, src, style和事件处理函数属性（比如onmouseover）。
- 对动态生成的JavaScript代码，这包括脚本部分以及HTML标签的事件处理属性（Event Handler，如onmouseover, onload）等进行Javascript编码
- 将不可信数据插入到HTML URL里时，对这些数据进行URL编码

**（3）HttpOnly**

将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。

现代web开发框架如vue.js、react.js等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。

### 点击劫持ClickJacking的攻防

http响应头：x-frame-option：deny

## 封装权限认证模块

### 为啥要封装这个？

### 用了axios，axios是啥

### axios和Fetch、xhr有啥区别？

**axios**

```lua
axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
```

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：

1. 从浏览器中创建 XMLHttpRequest
2. 支持 Promise API
3. 客户端支持防止CSRF
4. 提供了一些并发请求的接口（重要，方便了很多的操作）
5. 从 node.js 创建 http 请求
6. 拦截请求和响应
7. 转换请求和响应数据
8. 取消请求
9. 自动转换JSON数据

**fetch**

```javascript
fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });
```

一、fetch优势：

1. 语法简洁，更加语义化
2. 基于标准 Promise 实现，支持 async/await
3. 同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
4. 更加底层，提供的API丰富（request, response）
5. 脱离了XHR，是ES规范里新的实现方式

二、fetch存在问题
fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。

1. fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
2. fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
3. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
4. fetch没有办法原生监测请求的进度，而XHR可以

### **用了async，讲讲async await和promise的关系**

### 别的异步编程的解决方法？



***

## 移动端适配



## 首屏渲染时间

### 前端性能优化的常见指标有哪些？

- 白屏时间：从浏览器输入地址并回车后到页面开始有内容的时间；
- 首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间；
- 用户可操作时间节点：domready触发节点，点击事件有反应；
- 总下载时间：window.onload的触发节点。

### API window.performance是什么？

用来测量网页和Web应用程序性能的api

`memory字段`代表JavaScript对内存的占用。

`navigation字段`统计的是一些网页导航相关的数据

最重要的是`timing字段`的统计数据，它包含了网络、解析等一系列的时间数据。

- DNS查询耗时 = domainLookupEnd - domainLookupStart
- TCP链接耗时 = connectEnd - connectStart
- request请求耗时 = responseEnd - responseStart
- 解析dom树耗时 = domComplete - domInteractive
- 白屏时间 = domloading - fetchStart
- domready可操作时间 = domContentLoadedEventEnd - fetchStart
- onload总下载时间 = loadEventEnd - fetchStart

### 骨架屏

### 利用webpack去实现组件的按需加载



## 其他

### 你知道你的项目是怎么变成一个HTML的吗？

其实问这道题 是看你了不了解Webpack的。

基本上可以答是通过webpack打包构建成js之后 通过一个叫webpackHtmlPlugin 的插件注入到html的模板。



