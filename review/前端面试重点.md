## 1.跨域问题 

### **1.1为什么造成跨域？**

浏览器的同源策略，是一种安全限制，浏览器在发起请求的过程中，要求请求的URL地址与当前页面的URL保持一致，并且要求协议要相同，端口号要相同。

### 1.2 如何解决跨域问题？

- jsonp：

  只能用GET请求， 这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源 。

  jsonp跨域请求的关键就在于：

  **服务端要在返回的数据外层包裹一个客户端已经定义好的函数**

- cors：

  CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。 

  一般来说，后端在开发服务器的时候进行配置

  **配置了cors后http请求会多出哪些头？**

  简单请求：允许的域、允许携带cookie？

  特殊请求：允许的请求方法等

- 配置代理（webpack proxy）：在同源域名下假设一个代理服务器来转发，JAVAScript负责把请求发送到代理服务器上，代理服务器帮我们发送请求后，再把获得的响应的结果返回，这样就遵守了同源策略，实现跨域。webpack里可以配置

- webpack中间件

  如果是用node搭建的服务 可以通过配置webpack中间件 让前后端都跑在同一个端口上

- nginx反向代理 仅仅了解。。

 最常用的是 cors 这个后端配置下就行 在http header里解决这个问题 

## 2.CSS预处理

CSS预处理器是一种专门的编程语言，用来编写CSS，经过编译后，形成网页能够读懂的CSS文件。

主要特性包括：

模块化

工程化

可继承 复用

Mixin

两种 Sass（基于Ruby） Less（基于Node.js）

## 4.TS

TypeScript是JS的超集，我很少用，语法上与JS有一些区别，支持Class类继承，在运行的时候使用TS complier 编译成JS代码再运行。

## 5.防抖和节流

防抖是把重复请求取消，只响应最后一次请求

节流是把多次请求稀释，按一定的频率执行

手写一定要练一下

```javascript
// 防抖和节流
function debounce(fn,wait) {
    let timeout = null;
    return ()=>{
        clearTimeout(timeout); // 相当于每次点完重新计时了
        timeout = setTimeout(()=>{
            fn.apply(this,arguments);
        },wait)
    }
}

function throttle(fn,frequent){
    let canRun = true;
    if (!canRun){return;}
    canRun = false;
    setTimeout(()=>{
        fn.apply(this.arguments);
        canRun = true;
    },frequent)
}
```

## 5.异步编程(promise)

promise处理异步任务要会

使用promise处理异步任务。

promis意为承诺一个任务

支持链式调用

**Promise.prototype.then方法：链式操作**

Promise.prototype.then 方法返回的是一个新的 Promise 对象，因此可以采用链式写法。

getJSON("/posts.json").then(function(json) {  return json.post; }).then(function(post) {  // proceed });

上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。

如果前一个回调函数返回的是Promise对象，这时后一个回调函数就会等待该Promise对象有了运行结果，才会进一步调用。

getJSON("/post/1.json").then(function(post) {  return getJSON(post.commentURL); }).then(function(comments) {  // 对comments进行处理 });

这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的"横向发展"改为"向下发展"。

------

**Promise.prototype.catch方法：捕捉错误**

Promise.prototype.catch 方法是 Promise.prototype.then(null, rejection) 的别名，用于指定发生错误时的回调函数。

getJSON("/posts.json").then(function(posts) {  // some code }).catch(function(error) {  // 处理前一个回调函数运行时发生的错误  console.log('发生错误！', error); });

Promise 对象的错误具有"冒泡"性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。

getJSON("/post/1.json").then(function(post) {  return getJSON(post.commentURL); }).then(function(comments) {  // some code }).catch(function(error) {  // 处理前两个回调函数的错误 });

------

**Promise.all方法，Promise.race方法**

Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

```javascript
var p = Promise.all([p1,p2,p3]);
```

上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）

p 的状态由 p1、p2、p3 决定，分成两种情况。

- （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
- （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

下面是一个具体的例子。

// 生成一个Promise对象的数组 var promises = [2, 3, 5, 7, 11, 13].map(function(id){  return getJSON("/post/" + id + ".json"); });  Promise.all(promises).then(function(posts) {  // ...   }).catch(function(reason){  // ... });

Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

```
var p = Promise.race([p1,p2,p3]);
```

上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。

如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。

三种状态：resolved rejected pending

## js深拷贝、浅拷贝

- 浅拷贝（shallow copy）：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存。

- 深拷贝（deep copy）：复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变。

  

  深拷贝的实现方法：递归实现

  ```javascript
  function deepCopy(newobj, oldobj) {
      for (var k in oldobj) {
          // 判断我们的属性值属于那种数据类型
          // 1. 获取属性值  oldobj[k]
          var item = oldobj[k];
          // 2. 判断这个值是否是数组(首先判断数组是因为数组也属于对象)
          if (item instanceof Array) {
              newobj[k] = [];
              deepCopy(newobj[k], item);
          } else if (item instanceof Object) {
              // 3. 判断这个值是否是对象
              newobj[k] = {};
              deepCopy(newobj[k], item);
          } else {
              // 4. 属于简单数据类型
              newobj[k] = item;
          }
      }
  };
  ```

  

## js垃圾回收机制

**标记清除（常用）**

 当代码执行在一个环境中时(例如上面的 `speakLines`函数)，每声明一个变量，就会对该变量做一个标记(例如标记一个进入执行环境)；当代码执行进入另一个环境中时，也就是要离开上一个环境( `speakLines` 函数执行完毕，去执行其他的函数)，这时对上一个环境中的变量做一个标记，(例如标记一个离开执行环境)，等到垃圾回收执行时，会根据标记来决定要清除哪些变量进行释放内存 

**引用计数**

跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加一，如果该变量的值变成了别的， 则这个值的引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，当垃圾回收的时候，就会将 引用次数为0的进行回收，释放对应的内存 

## 6.回调函数

 就是将一个函数作为参数传递给另一个函数，作为参数的这个函数就是[回调函数](https://so.csdn.net/so/search?q=回调函数&spm=1001.2101.3001.7020)。 

跟异步函数搭配起来，共同处理异步任务。

回调队列： 

**分类：**

同步回调： 函数的执行顺序依然自上而下顺序执行 

异步回调：你走你的，我过我的

**回调地狱**：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件。

**回调地狱的解决方案**：Promise链式调用 ，**终极解决方案**：async/await


## 7.AJAX

传统的HTTP，一个请求对应一个页面，使用AJAX,在页面不刷新的情况下发起请求，处理响应

要会手写

```javascript
const xhr = new XMLHttpRequest;
xhr.open('GET','http://127.0.1');
xhr.send();
xhr.onreadystatechange = ()=>{
    if (xhr.readyState === 4){
        if (xhr.status>=200&&xhr.status<300){
            return function (response){...};
        }
    }
}
```

## fetch和axios

### axios

```lua
axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
```

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：

1. 从浏览器中创建 XMLHttpRequest
2. 支持 Promise API
3. 客户端支持防止CSRF
4. 提供了一些并发请求的接口（重要，方便了很多的操作）
5. 从 node.js 创建 http 请求
6. 拦截请求和响应
7. 转换请求和响应数据
8. 取消请求
9. 自动转换JSON数据

### fetch

```javascript
fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });
```

一、fetch优势：

1. 语法简洁，更加语义化
2. 基于标准 Promise 实现，支持 async/await
3. 同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
4. 更加底层，提供的API丰富（request, response）
5. 脱离了XHR，是ES规范里新的实现方式

二、fetch存在问题
fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。

1. fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
2. fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
3. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
4. fetch没有办法原生监测请求的进度，而XHR可以

## event loop

 [面试题：说说事件循环机制(满分答案来了) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904079353708557) 

事件循环机制是用来处理javaScript回调函数的问题，具体来说分为宏任务和微任务。

几个阶段：

timers：处理定时器，setTimeOut（）、setInterval（）

I/O,callbacks：除了setTimeOut（）、setInterval（）、setImmediate（）、socket.close()之外的回调函数都在这里执行

idle，prepare：livbu内置，不用关注

poll：轮询，等待还未完成的I/O，如果没有其他的要返回，会一直停留在这个阶段

check：执行setImmediate（）的回调

close：执行socket.close()的回调

宏任务： 宏任务：1. script (可以理解为外层同步代码)2. setTimeout/setInterval3. UI rendering/UI事件4. postMessage，MessageChannel5. setImmediate，I/O（Node.js） 

微任务： 微任务：1. Promise2.process.nextTick（Node.js） 3. Object.observe（已废弃；Proxy 对象替代）4. MutaionObserver 

三部分：

Call Stack函数调用栈：普通函数压入

Message Queue消息队列：setTimeOut中的回调函数进入消息队列，

Microtask Queue微任务队列：promise中then入队微任务

 总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。 

**setTimeOut(),setInterval(),setImmediate()以及process.nextTick()区别**

执行顺序

：process.nextTick()>setTimeOut()>setImmediate()

##  this的指向

- 全局中的指向：根据上下文环境，确定指向，一般来说window
- 普通函数调用：谁调用，指向谁
- 箭头函数调用：指向外层obj
- 事件绑定中的this：指向事件源
-  定时器中的this：定时器中的this->window，因为定时器中采用回调函数作为处理函数，而回调函数的this->window .
- 构造函数中的this：指向新的实例化对象

## 闭包

**讲一下闭包？**

闭包就是子函数可以访问上层函数的变量，在js中，变量的作用域属于函数作用域，函数执行后作用域就会被清理、内存也会随之被收回，但是由于闭包是建立在一个函数内部的子函数，由于其可以通过作用域链访问上层作用域，所以即使上级函数执行完，作用域也不会随之销毁，这时的返回子函数就是闭包。

**闭包解决了什么？/为什么要用闭包？**

闭包可以缓存上级作用域，函数懒执行。

闭包会常驻内存（慎用闭包）

**闭包存在的意义**

1、延长变量的生命周期

2、创建私有环境（面向对象编程）

**应用场景有哪些？**

AJAX请求的成功回调、事件绑定的回调方法、setTimeOut的延时回调都是闭包

## VUE中的data为什么是一个函数

​	实际上data就是一个闭包，vue的单个页面可能是由多个组件组成的，多个组件都可能有自己的私有作用域,所以要通过闭包来创建私有属性和方法。

## 作用域和作用域链

**作用域**

作用域只包括两种，全局作用域，函数作用域（函数创建）。

抽象概念，注意区分与执行上下文之间的区别。

 定义：作用域的集合就是作用域链
**1、函数在执行的过程中，先从自己内部寻找变量**
**2、如果找不到，再从创建当前函数所在的作用域去找，从此往上，也就是向上一级找。**
当在作用域内访问 变量/方法 的时候，会找离自己最近的那个 变量/方法 （就近原则） 

## JS事件捕获和事件冒泡

事件的三个阶段：

捕获阶段（又外到里）、目标阶段、冒泡阶段（又里到外）

默认绑定到冒泡阶段

常见的不支持冒泡的事件：

focus、blur、mouseenter、mouseleave、load、unload、resize

## 事件代理

事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。事件委托的优点

**【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒**

<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>

// ...... 代表中间还有未知数个 li

【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）

假设上述的例子中列表项li就几个，我们给每个列表项都绑定了事件；

在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者删除列表项li元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；

如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。

## 原型和原型链

**原型 prototype**：

原型是函数function特有的。

```javascript
let arr = [];
arr.prototype.a = 1;//会报错
```

```javascript
function fn() {
    
}
fn.prototype.a = 1;//不会报错
```

为函数function添加prototype的属性是为了在构造实例时继承给new出来的对象。

```javascript
function Person(){}

Person.prototype.name = 'zwf';
Person.prototype.age = 21;
Person.prototype.getAge = function (){
    console.log(this.age);//this指向new出来的对象
}

let zwf = new Person();

zwf.getAge();
```

**原型链（隐式原型_proto__）**

一个对象的隐式原型_proto__指向创建的他构造函数的prototype

原型链的概念，当我们访问一个对象的属性（或方法）时，会先在自己对象的属性中进行查找，如果查不到的话，再顺着原型链一个往上找，直到找到object的上一层null。如果还没找到，会报错。

![1646660027562](C:\Users\MECHREVO\AppData\Roaming\Typora\typora-user-images\1646660027562.png)

## 重排和重绘

### 什么是重排和重绘？

重排就是重新布局，耗费内存，成本大，重绘只是对某个部分进行重新绘制

### 如何减少重排和重绘

1、尽量减少Style的使用

2、尽量少使用display：none 会导致重排，可以用visibility：hidden代替（尽会造成重绘）

3、对resize事件监听时，函数要做防抖和节流处理

4、对动画元素使用absolute/fixed属性

## 变量提升

变量提升（Hoisting）被认为是， Javascript中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。在 [ECMAScript® 2015 Language Specification](https://www.ecma-international.org/ecma-262/6.0/index.html) 之前的JavaScript文档中找不到变量提升（Hoisting）这个词。不过，需要注意的是，开始时，这个概念可能比较难理解，甚至恼人。

例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

[了解更多](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting#了解更多)

[技术范例](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting#技术范例)

JavaScript 在执行任何代码段之前，将函数声明放入内存中的优点之一是，你可以在声明一个函数之前使用该函数。例如：

```
/**
* 正确的方式：先声明函数，再调用函数 (最佳实践)
*/
function catName(name) {
    console.log("我的猫名叫 " + name);
}

catName("Tigger");

/*
以上代码的执行结果是: "我的猫名叫 Tigger"
*/
```

Copy to Clipboard

上面的代码片按照是你的正常思维（先声明，后调用）去书写的。现在，我们来看看当我们在写这个函数之前调用这个函数会发生什么：

```
/**
* 不推荐的方式：先调用函数，再声明函数
*/

catName("Chloe");

function catName(name) {
    console.log("我的猫名叫 " + name);
}

/*
代码执行的结果是: "我的猫名叫 Chloe"
*/
```

Copy to Clipboard

即使我们在定义这个函数之前调用它，函数仍然可以工作。这是因为在 JavaScript 中**执行上下文**的工作方式造成的。

变量提升也适用于其他数据类型和变量。变量可以在声明之前进行初始化和使用。但是如果没有初始化，就不能使用它们。

译者注： 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。

[只有声明被提升](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting#只有声明被提升)

JavaScript 只会提升声明，不会提升其初始化。如果一个变量先被使用再被声明和赋值的话，使用时的值是 undefined。参见例子：

```
console.log(num); // Returns undefined
var num;
num = 6;
```

Copy to Clipboard

如果你先赋值、再使用、最后声明该变量，使用时能获取到所赋的值

```
num = 6;
console.log(num); // returns 6
var num;
```

Copy to Clipboard

再来看几个类似的例子：

```
// Example 1 - only y is hoisted
var x = 1;                 // 声明 + 初始化 x
console.log(x + " " + y);  // '1 undefined'
var y = 2;                 // 声明 + 初始化 y

// Example 2 - Hoists
var num1 = 3;                   // Declare and initialize num1
num2 = 4;                       // Initialize num2
console.log(num1 + " " + num2); //'3 4'
var num2;                       // Declare num2 for hoisting

// Example 3 - Hoists
a = 'Cran';              // Initialize a
b = 'berry';             // Initialize b
console.log(a + "" + b); // 'Cranberry'
var a, b;                // Declare both a & b for hoisting
```

## 数据结构 

手写快排？图的DFS BFS？

## HTML5 CSS3

这个不会问很多 一些简单的就行

## TCP/IP HTTP HTTPS UDP

### HTTP常见状态码：

 2XX——表明请求被正常处理了

1、200 OK：请求已正常处理。

201 created

2、204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

3、206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

3XX——表明浏览器需要执行某些特殊的处理以正确处理请求

4、301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。

5、302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。

6、303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。

当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。

7、304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。

8、307 Temporary Redirect：临时重定向。与302有相同的含义。

4XX——表明客户端是发生错误的原因所在。

9、400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。

10、401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。

11、403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）

12、404 Not Found：服务器上没有请求的资源。路径错误等。

5XX——服务器本身发生错误

13、500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。

14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。

### 三次握手四次挥手

**三次握手**

**第一次握手：**建立连接时，客户端发送SYN(syn = x)包到服务器，并进入到syn_sent状态。等待服务器确认；syn（Synchronize Sequence Numbers 同步序列编号）


**第二次握手**：服务器收到syn包，必须确认客户的syn(ack = x+1)，同时自己也发送一个syn(syn = y)包，即SYN+ ACK包。此时进入syn_recv状态



**第三次握手**：客户端收到syn+ack包，向服务器发送确认包ack（ack=y+1）。此包发送完毕，客户端和服务器进入到established状态。完成三次握手

![img](https://pic3.zhimg.com/80/v2-6ef32ea9be6147119a964a809428602e_720w.jpg)

**四次挥手**

**第一次握手：**客户端进程发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u

**第二次握手：**服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。

**第三次握手：**客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次握手：**客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

**梳理三个东西: 报文，序列号，状态**

**1。客户端** 发释放报文 FIN = 1, seq = u 进入fin-wait-1状态

**2。 服务端** 确认报文 ACK =1, ack = u+1, seq = v 进入close-wait状态

**2.1 客户端** 收到确认报文后变更状态为fin-wait-2状态

**3。服务器** 释放报文 FIN=1, ack = u + 1, seq = w 进入close-wait状态

**4。客户端** 确认报文 ACK = 1， ack = w+1, seq = u+1, 进入time-wait状态。在2个最长报文段的时间后进入closed状态，服务器在收到确认报文后，立即close

![img](https://pic4.zhimg.com/80/v2-18aab0092162b4a528f02a414f18214f_720w.jpg)

### HTTP 与 HTTPS 区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

  

### TCP和UDP的区别：

1、TCP 是面向连接的（三次握手建立连接），UDP 是无连接的即发送数据前不需要先建立链接。

 

2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，不保证可靠交付。 （并且因为 TCP 可靠，面向连接，不会丢失数据因此适合大数据量的交换）

 

3、TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。

 

4、TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。

 

5、TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。

 

6、TCP 是面向连接的可靠性传输，而 UDP 是不可靠的

## ![img](https://pic1.zhimg.com/80/v2-06bdd52997add27938607b33edea4068_720w.jpg)网络安全

XSS攻击和CSRF攻击

## 如何处理高度塌陷

方法一:
给父元素设置固定的高度，固定高度后，父元素的高度就无法自适应子元素的高度了。
弊端：但是不能让元素高度自适应了 。

方法二：
给父元素设置overflow：hidden，解决高度塌陷并能实现高度自适应的方法（遵循BFC的显示原则）

BFC显示原则：

- 父元素的垂直外边距不会和子元素重叠
- 开启BFC的元素不会被浮动元素所覆盖
- 开启BFC的元素可以包含浮动元素

弊端：只要里面的内容或者元素超出父元素以外，就会被隐藏；

**第四种：after伪类【各大公司推荐】**

可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用

在IE6中，不支持after，所以在IE6中还需要使用hasLayout来处理（zoom：1）

```html
.box:after{content:"";display:block;clear:both;}
```

## BFC

**如何触发BFC？**

- 根元素，即HTML元素
- float不为none
- position的值为absolute或者fixed
- display的值为inline-block,table-cell,table-caption
- overflow的值不为visible、clip
- flex元素


**BFC的作用？**

- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖
- 如果元素里面包含浮动元素，可以清除内部浮动（原理：父元素创建了BFC后，里面的子元素即使是float也会参与高度计算）
- 分属于不同BFC时，可以防止margin重叠

## MVVM设计模式

model：数据访问层 ajax axios fetch

view：html css template

viewmodel：提供一个双向数据绑定，在model和view之间进行通信

优势：低耦合 将ui和业务逻辑分开 可重用性强

## JavaScript空数组[]和空对象{}的布尔运算

空数组[]和空对象{}都是object类型：

console.log(typeof []); // 控制台输出：object
console.log(typeof {}); // 控制台输出：object


空数组[]转化为Number，会得到0；空对象{}转化为Number，会得到NaN：

console.log(Number([])); // 控制台输出0
console.log(Number({})); // 控制台输出NaN


实例：

if ([])
	console.log(1);
if ({})
	console.log(2);
if ([] == false)
	console.log(3);
if ({} == false) 
	console.log(4);
控制台输出：1 2 3



分析：

（1）空数组[]和空对象{}都是object类型，因此直接用于if判断条件时就会被转化为true。

（2）任意值与布尔值比较，都会将两边的值转化为Number。

如果将空数组[]与布尔值false比较，false转化为0，而空数组[]也转化为0，因此[] == false的判断得到true。
如果将空对象{}与布尔值false比较，false转化为0，而空对象{}转化为NaN，由于NaN与任何数都不相等，因此{} == false的判断得到false。
更多实例：
console.log(([0]) ? true : false); // true
console.log(([0] == false) ? true : false); // true
console.log(({x:0} == false) ? true : false); // false
分析：
[0]直接用于if判断条件时会被转化为true。
与布尔值比较，都会将两边的值转化为Number，[0]转换为0，{x:0}转换为NaN。

## position：absolute详解

综下所述，绝对定位相对于最近position不为static的父级元素来定位，但其中定位的位置还是有细微的差别的。

比方说，父元素设置为relative，设置内边距padding，子元素设置absolute，在left和top没有定义时，相对于父级定位元素的content（内容区width）定位；
在定义了top和left属性时，相对于父级元素的占位区定位（包含padding区域）



## CSS盒子模型

 ![CSS box-model](https://www.runoob.com/images/box-model.gif) 

## 虚拟Dom和diff算法

 [vue核心之虚拟DOM(vdom) - 简书 (jianshu.com)](https://www.jianshu.com/p/af0b398602bc) 

一维diff：

四种情况 

- 节点类型变了：这个过程称为REPLACE，直接将旧节点卸载并装载新节点。旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做效率不高。但为了避免O(n^3)的时间复杂度，这样是值得的。这也提醒了开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p没有意义。

-  **节点类型一样，仅仅属性或属性值变了。**我们将这个过程称之为**PROPS**。此时不会触发节点卸载和装载，而是节点更新。 

-  **文本变了**，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为**TEXT**。 

## Array ES6方法

![1646661393923](C:\Users\MECHREVO\AppData\Roaming\Typora\typora-user-images\1646661393923.png)



上图是一个真实的array对象。

**扩展运算符**

扩展运算符（spread）三个点（...）类似于rest参数的逆运算，

**rest参数是写在函数参数列表的尾部，将所输入的用逗号分隔的参数序列转换为一个数组**

而扩展运算符，是将一个数组转换成用逗号分隔的参数序列。

例子：

```javascript
let a = [1,2,3,4,5]
console.log(a);//[1,2,3,4,5]
console.log(...a);//1 2 3 4 5
```



**Array.from()**

将类数组对象（比如arguments）和具有iterator接口的对象转换为真正的数组。





实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。

```javascript
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});
// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
```

上面代码中，`querySelectorAll`方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用`filter`方法。

**map和forEach有什么区别**

 1.map ()会分配内存空间存储新数组并返回，forEach ()不会返回数据。

 2.forEach ()允许callback更改原始数组的元素。 map ()返回新的数组。 forEach ()针对每一个元素执行提供的函数，对数据的操作会改变原数组。 

**简而言之，map返回新数组，forEach修改原数组**

切片操作：

slice和splice

## link和@import的区别

**1.从属关系区别**
`@import`是 CSS 提供的语法规则，只有导入样式表的作用；`link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**
加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。

## 如何实现元素水平垂直居中

 **flex 布局 + margin: auto（推荐）**

我们只需写两行声明即可：先给父容器设置 `display: flex`，再给指定的子元素设置我们再熟悉不过的 `margin: auto`，即可让这个指定的子元素在**剩余空间**里，水平垂直居中。大功告成。

**绝对定位 + translate（无需指定子元素的宽高，推荐）**

```javascript
 .father{
            position: relative;
            min-height: 500px;
            background: pink;
        }
        .son {
            position: absolute;
            background: red;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
```

 这种写法，在没有指定子元素宽高的情况下，也能让其在父容器中垂直居中。因为 translate() 函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（动态计算宽高）。 

## 浏览器输入一个url发生了什么以及优化思路

DNS域名解析：

先在缓存中查找，如果没有再向上层服务器发起解析请求

建立TCP连接：

三次握手

发起HTTP请求：

接受HTTP响应：

浏览器解析html、布局渲染（一次或多次重排 设置style会导致重排）

**优化思路：**

1、减少DNS查询

DNS查询是一个递归的过程，域名层级越多，查询速度越慢，尽量将资源放在同一域名，可以减少DNS查询

2、TCP连接阶段：

TCP连接复用，在HTTP请求头中的connection加上keep-alive；http/2.0多路复用等

3、HTTP请求和响应阶段

- 避免不必要的重定向

- **减少cookie的大小，静态资源使用无cookie域名**

- 配置Etag

- 使用Gzip对HTML、CSS、JS、XML、JSON等资源进行高效压缩（在请求头加上Accept-Encoding: gzip, deflate）

- **懒加载，不在视窗范围内先不加载。**

  

4、渲染页面阶段

CSS放在<head>中，尽量不要写行内样式，通过事件委托（事件代理）减少绑定事件监听的节点，使用documentFragment暂存DOM，整理好以后再插入DOM树

## 强缓存和协商缓存

#### 强缓存总结

1. cache-control: max-age=xxxx，public
    客户端和代理服务器都可以缓存该资源；
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求
2. cache-control: max-age=xxxx，private
    只让客户端可以缓存该资源；代理服务器不缓存
    客户端在xxx秒内直接读取缓存,statu code:200
3. cache-control: max-age=xxxx，immutable
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
4. cache-control: no-cache
    跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
5. cache-control: no-store
    不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

#### 协商缓存总结：

 发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。 

## HTML新特性

语义标签、增强型表单、Canvas绘图、WebStorage、

## BOM和DOM有什么区别

BOM：brower Object Model

DOM：docum object model

dom和文档有关，bom和浏览器有关

dom的最根本对象是window.document

bom的最根本对象是window

## JS观察者模式

又称 发布者订阅者模式

## Vue原理：computed

什么是`computed`呢？要理解 `computed` 的工作原理，只需要理解下面三个问题

1、`computed` 也是响应式的

2、`computed` 如何控制缓存

3、依赖的 data 改变了，`computed` 如何更新

不懂 明天问问