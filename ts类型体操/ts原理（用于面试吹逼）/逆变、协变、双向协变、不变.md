## 类型安全和型变

    TypeScript 给 JavaScript 添加了一套静态类型系统，是为了保证类型安全的，也就是保证变量只能赋同类型的值，对象只能访问它有的属性、方法。


这是类型检查做的事情，遇到类型安全问题会在编译时报错。

但是这种类型安全的限制也不能太死板，有的时候需要一些变通，比如子类型是可以赋值给父类型的变量的，可以完全当成父类型来使用，也就是“型变（variant）”（类型改变）。

这种“型变”分为两种，一种是子类型可以赋值给父类型，叫做协变（covariant），一种是父类型可以赋值给子类型，叫做逆变（contravariant）。

**什么是子类型和父类型？**

比如 `7 extends number` 7就是number的子类型

再比如 `number extends any` number就是any的子类型，简而言之，子类型就是更加具体的类型。

## 协变（子类型赋值给父类型）
其中协变是很好理解的，比如我们有两个 interface：

```
interface Person {
  name: string;
  age: number;
}

interface ZWF {
  name: string;
  age: number;
  hobbies: string[];
}

let a:Person = {
    name:'zwf',
    age:125,
}
let b:ZWF = {
    name:'zwf',
    age:125,
    hobbies:[]
}

a = b //不会报错，这个就是协变

b = a //会报错
```

这里 ZWF 是 Person 的子类型，更具体，那么 ZWF 类型的变量就可以赋值给 Person 类

## 逆变（父类型赋值给子类型）

这里有两个函数，代码承接刚刚的上下文

```
let printHobbies:(zwf:ZWF)=>void

let printName:(person:Person)=>void;

printHobbies = (zwf:ZWF)=>{
    console.log(zwf.hobbies)
}

printName = (person:Person)=>{
    console.log(person.name);
}

printName = printHobbies; // 报错，子类型给父类型赋值

printHobbies = printName; // 不报错，父类型给子类型赋值
```

这里为什么子类型赋值给父类型会报错，反过来就不报错，这不是和刚刚相反了吗？

实际上不管是怎么变，ts始终都是要保证类型安全的。

这里 printHobbies函数里，会涉及到对 子类型 的一些操作，而子类型中的一些属性或者方法，父类型中可能没有，所以这里子类型赋值给父类型是会有问题的。

所以函数参数具有逆变性质

## 双向协变（ts2.x 特性）
上述的这种情况，实际上在ts 2.x中是支持的，也就是父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变”。

但是这明显是有问题的，不能保证类型安全，所以之后 ts 加了一个编译选项 strictFunctionTypes，设置为 true 就只支持函数参数的逆变，设置为 false 则是双向协变。

我们把 strictFunctionTypes 关掉之后，就会发现两种赋值都可以了；开启之后，函数参数就只支持逆变，子类型赋值给父类型就会报错：



## 不变

非父子类型之间不会发生型变

[!img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bf4a8be10b5413b96c302a34c6f33c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

## 父子类型的确定

像 java 里面的类型都是通过 extends 继承的，如果 A extends B，那 A 就是 B 的子类型。这种叫做名义类型系统（nominal type）。

而 ts 里不看这个，只要结构上是一致的，那么就可以确定父子关系，这种叫做结构类型系统（structual type）。

```
interface Person {
  name: string;
  age: number;
}

interface ZWF {
  name: string;
  age: number;
  hobbies: string[];
}

let a:Person = {
    name:'zwf',
    age:125,
}
let b:ZWF = {
    name:'zwf',
    age:125,
    hobbies:[]
}
```
Guang 和 Person 有 extends 的关系么？

没有呀。

那是怎么确定父子关系的？

通过结构，更具体的那个是子类型。这里的 ZWF 有 Person 的所有属性，并且还多了一些属性，所以 ZWF 是 Person 的子类型。

注意，这里用的是更具体，而不是更多。

判断联合类型父子关系的时候， 'a' | 'b' 和 'a' | 'b' | 'c' 哪个更具体？

'a' | 'b' 更具体，所以 'a' | 'b' 是 'a' | 'b' | 'c' 的子类型。