# react fiber是什么
在数据更新时，react生成了一棵虚拟dom树，在react中，如果修改父组件的状态，父子组件都会重新渲染，这与在vue中不同，给diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。js占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了react fiber。
react fiber没法让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。

## fiber是一种新的数据结构
react fiber使得diff阶段有了被保存工作进度的能力，这部分会讲清楚为什么。
我们要找到前后状态变化的部分，必须把所有节点遍历。

[!img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28d54076b61245b5830d98960d027b79~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在老的架构中，节点以树的形式被组织起来：每个节点上有多个指针指向子节点。要找到两棵树的变化部分，最容易想到的办法就是深度优先遍历，规则如下：

从根节点开始，依次遍历该节点的所有子节点；
当一个节点的所有子节点遍历完成，才认为该节点遍历完成；

如果你系统学习过数据结构，应该很快就能反应过来，这不过是深度优先遍历的后续遍历。根据这个规则，在图中标出了节点完成遍历的顺序。
这种遍历有一个特点，必须一次性完成。假设遍历发生了中断，虽然可以保留当下进行中节点的索引，下次继续时，我们的确可以继续遍历该节点下面的所有子节点，但是没有办法找到其父节点——因为每个节点只有其子节点的指向。断点没有办法恢复，只能从头再来一遍。

在新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber，它的遍历规则如下：

从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；
当一个节点的所有子节点遍历完成，才认为该节点遍历完成；

根据这个规则，同样在图中标出了节点遍历完成的顺序。跟树结构对比会发现，虽然数据结构不同，但是节点的遍历开始和完成顺序一模一样。不同的是，当遍历发生中断时，只要保留下当前节点的索引，断点是可以恢复的——因为每个节点都保持着对其父节点的索引。


这就是react fiber的渲染可以被中断的原因。树和fiber虽然看起来很像，但本质上来说，一个是树，一个是链表。

## fiber是纤程

被认为是协程的一种实现形势，协程是比线程更小的调度单位，开启、暂停 可以由程序员控制。

react fiber是通过requestIdleCallback这个api去控制组件渲染的进度条。

requestIdleCallback是一个属于宏任务的回调，就像setTimeout一样。不同的是，setTimeout的执行时机由我们传入的回调时间去控制，requestIdleCallback是受屏幕的刷新率去控制。只需要知道它每隔16ms会被调用一次，它的回调函数可以获取本次可以执行的时间，每一个16ms除了requestIdleCallback的回调之外，还有其他工作，所以能使用的时间是不确定的，但只要时间到了，就会停下节点的遍历。

## fiber如何让出控制权

**关于requestIdleCallback**
接受一个callback，这个callback会接受一个由浏览器高速你的执行剩余时间的参数 IdleDeadline。
通过下列代码获取每一帧，浏览器的渲染之后的剩余时间。
```js
    window.requestIdleCallback((idleDeadLine)=>{
        //可以放一些我们想做的事情，比如说fiber节点的调和
      console.log(idleDeadLine.timeRemaining())
    })
```
而实际上，浏览器会最多给出50ms的空闲时间给我们处理想做的事情，比如我们做的事情非常耗时，浏览器知道我们耗时，但为了页面呈现尽量不要太卡顿，同时又要照顾js线程，浏览器会主动将一帧的用时从16.66ms提升到50ms，也就是1s20帧。

## react中的fiber是如何运转的

### 调和（Reconciliation）
这个阶段做的时间很多，fiber的创建、diff对比等，都在这个阶段，在对比完成后可以下次提交，这个阶段可以被暂停。
### 提交（commit）
将协调阶段计算出来的变更一次性提交，不可中断。

