> 常见手写题

# 常见JS手写

## 1. 手写实现new

```js
function myNew(con) {
    let obj = Object.create(con.prototype);
    let res = con.call(obj,[...arguments].slice(1));
    if((typeof res === "obj" ||  typeof res === "function") && res !== null) {
        return res;
    }
    return obj;
}
```

## 2. 手写实现call

```js
Function.prototype._call = function (context) {
    // 考虑null undefined 或者context不是对象的情况
    context = context ? Object(context) : window;
    context.fn = this; // 指向函数，所以肯定不能使用箭头函数
    let args = [];
    // 这里为什么推入的不是数字，而是数组的表达呢，这是为了防止，参数是字符串的形式
    for (let i = 1; i < arguments.length; i++) {
        args.push(`arguments[${i}]`);
    }
    let res = eval("context.fn(" + args + ")");
    delete context.fn;
    return res;
};
```

## 3. 手写实现apply

```js
Function.prototype._call = function (context, array) {
    // 考虑null undefined 或者context不是对象的情况
    context = context ? Object(context) : window;
    context.fn = this; // 指向函数，所以肯定不能使用箭头函数
    let arr = [];
    if (!array) {
        // 这里不能用长度判断，因为，不知道是否传入有参数，那么可能没有length这个属性
        res = context.fn();
    } else {
        for (let i = 0; i < array.length; i++) {
            arr.push("array[" + i + "]");
        }
        res = eval("context.fn(" + arr + ")");
    }
    delete context.fn;
    return res;
};

```

## 4. 手写bind

1. 返回一个新的函数（this的值改变），且这个函数的this值不会再被改变（闭包的原理)
2.  函数柯里化，也就是说可以先传递一部分参数 
3. 绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用 来构建一个值的，**原来提供的 this 就会被忽略**。并且会继承prototype上的值。

```js
Function.prototype._bind = function (context) {
    // 保存函数
    let fn = this;
    let args1 = [...arguments].splice(1); // 当然也可已使用
    Array.prototype.slice.call(arguments, 1);
    return function () {
        /* 不能在这里保存函数，这里的this会变成window */
        let args2 = [...arguments];
        fn.apply(context, [...args1, ...args2]);
    };
};
```

**实现new的效果：**

一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。且返回的实例还是会继承构造函数的构造器属性与原型属 性，并且能正常接收参数。

```js
Function.prototype.bind_ = function (contenxt) {
    let fn = this; // 保存函数
    let args1 = [...arguments].splice(1); // 当然也可已使用
    Array.prototype.slice.call(arguments, 1);
    let bound = function () {
        /* 不能在这里保存函数，这里的this会变成window */
        let args2 = [...arguments];
        fn.apply(this instanceof fn ? this : contenxt, [...args1, ...args2]); //或者 args1.concat(args2);
    };
    bound.prototype = fn.prototype;
    return bound;
};

```

**最终代码：**

```js
Function.prototype.bind_ = function (contenxt) {
    if (typeof this !== "function") {
        throw new Error(
            "Function.prototype.bind - what is trying to be bound is not callable"
        );
    }
    let fn = this;
    let args1 = [...arguments].splice(1);
    // 防止fn的原型被改变
    let fNOP = function () {};
    let bound = function () {
        let args2 = [...arguments];
        return fn.apply(this instanceof fn ? this : contenxt, [
            ...args1,
            ...args2,
        ]);
    };
    // 这里需要注意下
    fNOP.prototype = fn.prototype;
    bound.prototype = new fNOP();
    return bound;
};

```

## 5. 手写实现instanceof

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

```js
function myInstanceof(left, right) {
    // 这里先用typeof来判断基础数据类型，如果是，直接返回false,可能还需要处理函数
    if (typeof left !== "object" || left === null) return false;
    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
    if (typeof right !== "function") {
        throw new Error("不是函数");
    }
    let proto = Object.getPrototypeOf(left);
    while (true) {
        if (proto === null) return false;
        if (proto === right.prototype) return true; //找到相同原型对象，返回true
        proto = Object.getPrototypeof(proto);
    }
}

```

## 6. 实现deepClone

从这里就可以引出weakMap的区别，和JavaScript的垃圾回收机制。 还要考虑到Symbol的赋值，如何获取对象的Symbol属性

```js
let cloneRegExp = function (reg = /d+/i) {
    let flags = reg.flags;
    console.log(flags);
    let newReg = new RegExp(reg.source, flags);
    newReg.lastIndex = reg.lastIndex;
    return newReg;
};
function deepClone(obj, hash = new WeakMap()) {
    if (obj === null || typeof obj !== "object") return obj;
    if (typeof obj === "function") return obj;
    if (obj instanceof RegExp) {
        return cloneRegExp(obj);
    }
    if (obj instanceof Date) {
        return cloneDate(obj);
    }
    // 处理循环引用
    if (hash.has(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor();
    hash.set(obj, cloneObj);
    for (let k in obj) {
        if (obj.hasOwnProperty(k)) {
            cloneObj[k] = deepClone(obj[k], hash);
        }
    }
    return cloneObj;
}
```

![image-20220802183237906](C:\Users\fujiaxu\AppData\Roaming\Typora\typora-user-images\image-20220802183237906.png)

## 7. 数组扁平化

[(9条消息) JavaScript之数组扁平化_我是真的垃圾啊的博客-CSDN博客](https://blog.csdn.net/fujiaxu666/article/details/122419876?spm=1001.2014.3001.5501)

## 8. 函数柯里化

原理：闭包，延长的变量的生命周期，保存了当前的环境，是的外部可以访问到内部的变量。 可以复用参数，比如打折。 使用fn.length可以获取函数需要的参数

```js
function currying(fn, ...args1) {
    if (typeof fn !== 'function') {
    	throw new TypeError()
  	}
    let len = fn.length;
    return function (...args2) {
        let arg = [...args1, ...args2];
        if (arg.length >= len) {
            return fn.apply(this, arg);
        } else {
            return currying.call(this, fn, ...arg);
        }
    };
}

```

## 9. 手写JSON

## 10. 手写lodash的get方法

## 11. 手写洗牌算法

```js
function shuffle(arr = []) {
    for (let i = arr.length - 1; i >= 0; i--) {
        let rIndex = Math.floor(Math.random() * i);
        let t = arr[i];
        arr[i] = arr[rIndex];
        arr[rIndex] = t;
    }
}
let arr = [1, 2, 3, 4, 5, 6, 7];
shuffle(arr);
console.log(arr);

```

## 12. 继承手写

[JavaScript深入之继承的多种方式和优缺点 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903477819211784#comment)

继承方式：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。

一、原型链继承

```js
function Parent() {
    this.name = "fjx";
    this.age = [1, 2, 3];
}
Parent.prototype.getName = function () {
    console.log(this.name);
};
//
function Child() {}
Child.prototype = new Parent();
// 之后就可定义自己的方法了
// 不能继承父类的静态方法
let c = new Child();
c.getName();

```

缺点：

 多个孩子共享实例的属性，如果是引用属性，那么问题大大的。 

不能继承静态方法。 

在创建 Child 的实例时，不能向Parent传参, 只能之前new 的时候传递参数.

二、构造函数继承

```js
function Parent() {
    this.name = "fjx";
    this.age = [1, 2, 3];
}
Parent.prototype.getName = function () {
    console.log(this.name);
};
Parent.hello = function () {
    console.log("hello");
};
function Child() {
    Parent.call(this);
}
let c = new Child();
// c.getName();
// c.hello();

```

优点：多个实例不共享属性了，解决了原型链继承的一个缺点。避免了引用类型的属性被所有实例共 享。可以在 Child 中向 Parent 传参。

缺点：不能继承方法

三、组合继承

```js
function father() {
this.age = 21;
this.person = [1, 2, 3];
}
father.prototype.say = function () {
return "hello";
};
function son() {
father.call(this);
}
son.prototype = new father();// 这里为什么是new，需要好好想想
son.prototype.constructor = son;
// 可以写自己的原型上的方法了
let SON = new son();
console.log(SON,SON.say());

```

优点：

融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

 缺点：

调用了两次构造函数

四、原型式继承

> ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

```js
function createObj(o) {
	function F(){}
	F.prototype = o;
	return new F();
}

```

包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

五、寄生式继承

```js
function createObj (o) {
	let clone = object.create(o);
	clone.sayName = function () {
	console.log('hi');
	}
	return clone;
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

六、寄生组合式继承

这是在组合继承的基础上进行优化，因为组合继承调用了两次构造函数（call 和 new father()）， 对于call的调用，这是不可避免的，所以我们要想办法来优化掉new father() 这一步，我们其实只是想要 间接访问原型，所以我们就可以使用Object.create(prototype,propertyObject)

```js
function Parent(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
Parent.prototype.getName = function () {
    console.log(this.name);
};
function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}
// 关键的三步
var F = function () {};
F.prototype = Parent.prototype;
Child.prototype = new F();
var child1 = new Child("kevin", "18");
console.log(child1);
```



## 13. 手写防抖节流

简单版本：[「中高级前端面试」JavaScript手写代码无敌秘籍 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903809206976520#heading-19)

防抖：

防抖和节流都是为了降低触发的次数，达到性能优化的目的。 防抖 最后我们再思考一个小需求，我希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒 钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点 击后，取消防抖，这样我再去触发，就可以又立刻执行啦。

(一直推迟)

```js
```

节流：

（一段时间只执行一次）

## 14. 手写Object.create()

[Object.create() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

[Object.defineProperty() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

[Object.defineProperties() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)

```js

function create(parentPrototype, props) {
  function Fn() {
 
  }
  Fn.prototype = parentPrototype;
  let fn = new Fn();
  for (let key in props) {
    Object.defineProperty(fn, key, {
      enumerable: true, // 如果不枚举对象中无法查看到这个对象
      ...props[key]
    })
  }
  return fn
}
```



## 15. 加入迭代器

```js
```



# 设计模式

## 1. 发布订阅模式

```js
class EventEmitter {
    constructor() {
        // 事件对象，存放订阅的名字和事件
        this.events = {};
    }
    // 订阅事件的方法
    on(eventName, callBack) {
        if (!this.events[eventName]) {
            // 如果事件不存在，就创建一个该时间名的数组，因为一个事件名可以订阅多个事件处理函
            数;
            this.events[eventName] = [callBack];
        } else {
            // 如果已存在
            this.events[eventName].push(callBack);
        }
    }
    // 触发事件的方法
    emit(eventName) {
        this.events[eventName] &&
            this.events[eventName].forEach((v) => {
                v();
            });
    }
    // 移除订阅事件
    removeListener(eventName, callback) {
        if (this.events[eventName]) {
            this.events[eventName] = this.events[eventName].filter((v) => {
                v !== callback;
            });
        }
    }
    // 只执行一次的订阅事件，然后移除
    once(eventName, callback) {
        // 绑定的时fn, 执行的时候会触发fn函数
        let fn = () => {
            callback(); // fn函数中调用原有的callback
            this.removeListener(eventName, fn); // 删除fn, 再次执行的时候之后执行一次
        };
        this.on(eventName, fn);
    }
}

```



# Promise手写题目

## 1. Promise.all()

完成（Fulfillment）： 

如果传入的可迭代对象为空， Promise.all 会同步地返回一个已完成（resolved）状态的 promise 。 如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise ， Promise.all 返回的 promise 异步地变为完成。 在任何情况下， **Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭 代参数对象的值（也包括非 promise 值）**。

失败/拒绝（Rejection）： 

**如果传入的 promise 中有一个失败（rejected）， Promise.all 异步地将失败的那个结果给失败状 态的回调函数，而不管其它 promise 是否完成。** 

1）传入参数为一个空的可迭代对象，则直接进行resolve。 2）如果参数中有一个promise失败，那么Promise.all返回的promise对象失败。 3）在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组 

利用闭包，在外面定义一个长度，每当一个promise完成时，那么长度就加一，直到全部完成。

```js
Promise.all = function (promises) {
    return new Promise((resolve, reject) => {
        let len = promises.length;
        let res = [];
        // 参数可以不是数组，但必须具有 Iterator 接口
        if (typeof promises[Symbol.iterator] !== "function") {
            reject("Type error");
        }
        if (len === 0) {
            resolve([]);
        } else {
            let count = 0;
            for (let i = 0; i < len; i++) {
                // 这里为什么不直接使用promises[i].then，因为可能他不是一个promise
                Promise.resolve(promises[i])
                    .then((data) => {
                        res[i] = data;
                        if (++count === len) {
                            resolve(res);
                        }
                    })
                    .catch((err) => {
                        reject(err);
                    });
            }
        }
    });
};

```

## 2. Promise.race

Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回 的 promise就会解决或拒绝。 

如果传的迭代是空的，则返回的 promise 将永远等待。

只要有一个完成就行，不管是成功还是失败。 也可以使用catch 来接受错误。

```js
Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        // 还有迭代器的判断
        // 参数可以不是数组，但必须具有 Iterator 接口
        if (typeof promises[Symbol.iterator] !== "function") {
            reject("Type error");
        }
        let len = promises.length;
        if (len === 0) return;
        for (let i = 0; i < len; i++) {
            Promise.resolve(promises[i]).then(
                (data) => {
                    resolve(data);
                    return;
                },
                (err) => {
                    reject(err);
                    return;
                }
            );
        }
    });
};


```

## 3. Promise.allSettled()

```js
function myPromiseSettled(promises) {
  return new Promise((resolve) => {
    if (typeof promises[Symbol.iterator] !== "function") {
            reject("Type error");
    }
    let settledCounts = 0
    let promisesNumber = promises.length
    let settled = []
    for (let i = 0; i < promisesNumber; i++) {
      Promise.resolve(promises[i])
        .then((val) => {
          settledCounts++
          let temp = {}
          temp.status = 'fulfilled'
          temp.value = val
          settled.push(temp)
          if (settledCounts === promisesNumber) {
            resolve(settled)
          }
        })
        .catch((reason) => {
          settledCounts++
          let temp = {}
          temp.status = 'rejected'
          temp.value = reason
          settled.push(temp)
          if (settledCounts === promisesNumber) {
            resolve(settled)
          }
        })
    }
  })
}
```

## 4. 手写ajax

[面试题：手写ajax - 掘金 (juejin.cn)](https://juejin.cn/post/6992604888165253156)https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

```js
const getJSON = function (url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.onreadystatechange = function () {
      // 0 1 2 3 4
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200 || xhr.status === 304) {
        resolve(xhr.responseText);
      } else {
        reject(new Error(xhr.responseText));
      }
    };
    xhr.send();
  });
};
```

## 5. 异步加载图片

```js
function loadImg(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            console.log("图片加载成功");
            resolve(img);
        };
        img.onerror = () => {
            reject("失败");
        };
        img.src = url;
    });
}


```

## 6. 每隔一秒输出1,2,3

也可以使用reduce。 利用链式调用

```js
let p = Promise.resolve();
for (let i = 1; i <= 3; i++) {
    p = p.then((res) => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(i);
                resolve();
            }, 1000);
        });
    });
}

```



## 7. 红绿灯

```js
function red() {
    console.log("red");
}
function green() {
    console.log("green");
}
function yellow() {
    console.log("yellow");
}
const light = (fn, time) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            fn();
            resolve();
        }, time);
    });
};
function step() {
    Promise.resolve()
        .then((res) => {
            return light(red, 3000);
        })
        .then(() => {
            return light(green, 2000);
        })
        .then(() => {
            return light(yellow, 1000);
        })
        .then(() => {
            step();
        });
}
step();

```

## 8.  限制异步操作的并发个数并尽可能快的完成全部

all:

```js
```

race:

```js
```

